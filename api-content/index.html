{"posts":[{"title":"mysql无损/半同步复制","content":"1.参数文件里加 plugin_dir=/usr/local/mysql/lib/plugin plugin_load = &quot;rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so&quot; loose_rpl_semi_sync_master_enabled = 1 loose_rpl_semi_sync_slave_enabled = 1 loose_rpl_semi_sync_master_timeout = 5000 2.主库准备步骤 grant replication slave, replication client on *.* to rep@'192.168.56.%' identified by '123456'; flush privileges; mysql&gt; show master status; +------------+----------+--------------+------------------+----------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------+----------+--------------+------------------+----------------------------------------------+ | bin.000007 | 57566891 | | | 35d3ad22-8862-11ea-97a1-080027bb5279:1-43998 | +------------+----------+--------------+------------------+----------------------------------------------+ 3.备库准备步骤 change master to master_host='192.168.56.101',master_user='rep',master_password='123456',master_log_file='bin.000007', master_log_pos=57566891,master_port = 3306; 4.测试 # 主库执行 mysql&gt; show variables like '%rpl%'; +-------------------------------------------+------------+ | Variable_name | Value | +-------------------------------------------+------------+ | rpl_semi_sync_master_enabled | ON | | rpl_semi_sync_master_timeout | 5000 | | rpl_semi_sync_master_trace_level | 32 | | rpl_semi_sync_master_wait_for_slave_count | 1 | | rpl_semi_sync_master_wait_no_slave | ON | | rpl_semi_sync_master_wait_point | AFTER_SYNC | | rpl_semi_sync_slave_enabled | ON | | rpl_semi_sync_slave_trace_level | 32 | | rpl_stop_slave_timeout | 31536000 | +-------------------------------------------+------------+ 9 rows in set (0.00 sec) mysql&gt; show global status like &quot;%rpl%&quot;; +--------------------------------------------+-------+ | Variable_name | Value | +--------------------------------------------+-------+ | Rpl_semi_sync_master_clients | 1 | | Rpl_semi_sync_master_net_avg_wait_time | 0 | | Rpl_semi_sync_master_net_wait_time | 0 | | Rpl_semi_sync_master_net_waits | 0 | | Rpl_semi_sync_master_no_times | 1 | | Rpl_semi_sync_master_no_tx | 2 | | Rpl_semi_sync_master_status | ON | | Rpl_semi_sync_master_timefunc_failures | 0 | | Rpl_semi_sync_master_tx_avg_wait_time | 0 | | Rpl_semi_sync_master_tx_wait_time | 0 | | Rpl_semi_sync_master_tx_waits | 0 | | Rpl_semi_sync_master_wait_pos_backtraverse | 0 | | Rpl_semi_sync_master_wait_sessions | 0 | | Rpl_semi_sync_master_yes_tx | 0 | | Rpl_semi_sync_slave_status | OFF | +--------------------------------------------+-------+ 15 rows in set (0.00 sec) # 从库执行 mysql&gt; show global variables like '%semi%'; +-------------------------------------------+------------+ | Variable_name | Value | +-------------------------------------------+------------+ | rpl_semi_sync_master_enabled | ON | | rpl_semi_sync_master_timeout | 5000 | | rpl_semi_sync_master_trace_level | 32 | | rpl_semi_sync_master_wait_for_slave_count | 1 | | rpl_semi_sync_master_wait_no_slave | ON | | rpl_semi_sync_master_wait_point | AFTER_SYNC | | rpl_semi_sync_slave_enabled | ON | | rpl_semi_sync_slave_trace_level | 32 | +-------------------------------------------+------------+ 8 rows in set (0.00 sec) mysql&gt; stop slave io_thread; Query OK, 0 rows affected (0.00 sec) # 主库执行 mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; create database test; Query OK, 1 row affected (5.00 sec) ---(rpl_semi_sync_master_timeout设置的5秒超时) mysql&gt; show global status like &quot;%rpl%&quot;; +--------------------------------------------+-------+ | Variable_name | Value | +--------------------------------------------+-------+ | Rpl_semi_sync_master_clients | 0 | | Rpl_semi_sync_master_net_avg_wait_time | 0 | | Rpl_semi_sync_master_net_wait_time | 0 | | Rpl_semi_sync_master_net_waits | 0 | | Rpl_semi_sync_master_no_times | 2 | | Rpl_semi_sync_master_no_tx | 3 | | Rpl_semi_sync_master_status | OFF | | Rpl_semi_sync_master_timefunc_failures | 0 | | Rpl_semi_sync_master_tx_avg_wait_time | 0 | | Rpl_semi_sync_master_tx_wait_time | 0 | | Rpl_semi_sync_master_tx_waits | 0 | | Rpl_semi_sync_master_wait_pos_backtraverse | 0 | | Rpl_semi_sync_master_wait_sessions | 0 | | Rpl_semi_sync_master_yes_tx | 0 | | Rpl_semi_sync_slave_status | OFF | +--------------------------------------------+-------+ 15 rows in set (0.00 sec) # 从库执行 start slave io_thread; # 主库执行 mysql&gt; show global status like &quot;%rpl%&quot;; +--------------------------------------------+-------+ | Variable_name | Value | +--------------------------------------------+-------+ | Rpl_semi_sync_master_clients | 1 | | Rpl_semi_sync_master_net_avg_wait_time | 0 | | Rpl_semi_sync_master_net_wait_time | 0 | | Rpl_semi_sync_master_net_waits | 1 | | Rpl_semi_sync_master_no_times | 2 | | Rpl_semi_sync_master_no_tx | 3 | | Rpl_semi_sync_master_status | ON | | Rpl_semi_sync_master_timefunc_failures | 0 | | Rpl_semi_sync_master_tx_avg_wait_time | 0 | | Rpl_semi_sync_master_tx_wait_time | 0 | | Rpl_semi_sync_master_tx_waits | 0 | | Rpl_semi_sync_master_wait_pos_backtraverse | 0 | | Rpl_semi_sync_master_wait_sessions | 0 | | Rpl_semi_sync_master_yes_tx | 0 | | Rpl_semi_sync_slave_status | OFF | +--------------------------------------------+-------+ 15 rows in set (0.00 sec) ","link":"https://hkxtor.github.io/BwozcZWlU/"},{"title":"MySQL自带的性能压力测试工具mysqlslap","content":"--only-print 只打印测试语句而不实际执行。 --detach=N 执行N条语句后断开重连。 # 单线程测试。测试做了什么。 mysqlslap -a -uroot -p123456 # 多线程测试。使用–concurrency来模拟并发连接。 mysqlslap -a -c 100 -uroot -p123456 # 迭代测试。用于需要多次执行测试得到平均值。 mysqlslap -a -i 10 -uroot -p123456 mysqlslap --auto-generate-sql-add-autoincrement -a -uroot -p123456 mysqlslap -a --auto-generate-sql-load-type=mixed -uroot -p123456 mysqlslap -a --auto-generate-sql-secondary-indexes=3 -uroot -p123456 mysqlslap -a --auto-generate-sql-write-number=1000 -uroot -p123456 mysqlslap --create-schema world -q &quot;select count(*) from City&quot; -uroot -p123456 mysqlslap -a -e innodb -uroot -p123456 mysqlslap -a --number-of-queries=10 -uroot -p123456 # 测试同时不同的存储引擎的性能进行对比： mysqlslap -a --concurrency=50,100 --number-of-queries 1000 --iterations=5 --engine=myisam,innodb --debug-info -uroot -p123456 # 500和1000个并发分别得到一次测试结果(Benchmark)，并发数越多，执行完所有查询的时间越长。为了准确起见，可以多测试几次: mysqlslap -a --concurrency=500,1000 --auto-generate-sql-add-autoincrement --auto-generate-sql-secondary-indexes=10 --number-of-queries 2000 --iterations=5 Benchmark Average number of seconds to run all queries: 1.551 seconds Minimum number of seconds to run all queries: 1.441 seconds Maximum number of seconds to run all queries: 1.716 seconds Number of clients running queries: 500 Average number of queries per client: 4 Benchmark Average number of seconds to run all queries: 1.734 seconds Minimum number of seconds to run all queries: 1.589 seconds Maximum number of seconds to run all queries: 1.911 seconds Number of clients running queries: 1000 Average number of queries per client: 2 ","link":"https://hkxtor.github.io/DQakzE_dy/"},{"title":"如何判断数据库IO是否慢","content":"1. 引言 一个项目的数据库响应慢的问题，结论就是操作系统层面上的IO性能差的问题，怎么样才能更有说服力。 我们一般衡量IO性能主要用两种指标来衡量。 响应时间：用微秒来测量完成一项操作所需的时间，这个一般由oracle来采集统计。 吞吐量：以每个单位时间内完成的操作数量来测量。这个一般通过操作系统下的工具来统计，例如iostat。 本文主要是阐述如何从oracle的角度来确定IO是否慢，不再详细说明吞吐量及其测量方法。 2. 怎么才算IO“慢” IO慢是一个很主观的术语，它更多的取决于用户对系统和硬件的预期和实际的差异，这个差异是一个比较主观的感觉，量化到具体性能指标来看，在企业级平台下，当IO请求的响应时间大于10ms时，用户会开始敏感。不过响应时间是会不断变化的，有可能是数据从文件系统迁移到共享存储上，也可能是存储设备出现异常，又或者是业务增长导致的IO性能达到峰值。这就需要通过对响应时间这个指标作出作出多维度的测量。 3. 响应时间 硬件不必对于每个IO请求都有相同的反映。总会有可能出现高峰和低谷。因此使用平均值是一种测量响应时间的通用方法。 注意：为了减缓这种高峰/低谷的异常场景带来的问题，样例数据量需要比较大。样例数据量应该至少是每小时1000次操作，目的就是为了提供给决测更可信和实用的依据。 IO的类型 平均响应时间直接关联到具体的IO类型： 读或写 单块或多块单块IO，指一次只读一个块。例如，当一个session等待一个单块IO时，典型的等待事件就是“db file sequential read”，表明正在等待需要的块。 多块读指的是一次读多个块，从2到128个Oracle块不等，依赖于块的大小与操作系统设置。通常一个多块请求容量上有1MB的限制。例如当一个session等待一次多块IO时，典型的等待事件就是“db file scattered read”，表明正在等待需要的块。 同步或异步同步(阻塞)操作等待硬件完成物理IO，完成后能得到通知，合理地管理操作的成功或失败(成功读的情况下可以接收结果)。当需要等待系统调用结果的时候，进程的执行是被堵塞的。 对于异步(非阻塞)操作，一旦IO请求传递到硬件，或放入操作系统的队列中(典型的情况是物理IO开始之前)，系统调用会立即返回。进程的执行不会被堵塞，因为它不需要等待系统调用的结果。它能继续执行，当IO操作有结果时再接收。 响应时间的阈值 一次典型的多块同步读64x 8k(总计512KB)的平均时间应该在未出现IO变慢的情况下大约是20毫秒左右。小请求应该更快(10-20毫秒)，大请求的消耗时间应该不多于25毫秒。异步操作应该至少和同步操作一样快，甚至还要更快。单块读至少应该和多块读一样快，甚至还要更快。“log file parallel write”，“control file write”和“direct path writes“等待时间应该不多于15毫秒。数据文件写的测量不像读那样简单。DBWR以批量的方式(&quot;db file parallel write&quot;)异步写入块，现在还没有写操作响应时间的标准。如果DBWR(多块或单块，带或不带IO salves)足够快速能够清理脏块，那么其他的等待事件和统计信息就会显露出来。作为规则，超过上述等待事件时间的等待事件都应该详细分析，当对比之前的时间消耗，有明显变化时更需要知晓。 注意：当系统低于这些最大阈值的时候，并不意味着没有其他的调优方法。 响应时间因系统而有所不同。例如，接下来的几项内容可以看做是正常平均值： 多块同步读时间是10毫秒。 单块同步读时间是5毫秒。 'log file parallel write'时间是3毫秒。 以上是基于多块IO比单块IO需要更多的IO子系统资源的前提。如果接受这些建议，redo日志最好放在最快的磁盘，并且没有其它并发活动的争用。 以下是各IO相关等待事件的响应时间阈值： Wait Event R/W Synchronous/ Asynchronous Singleblock/ Multiblock Elapsed Time control file parallel write Write Asynchronous Multi &lt; 15ms control file sequential read Read Synchronous Single &lt; 20 ms db file parallel read Read Asynchronous Multi &lt; 20 ms db file scattered read Read Synchronous Multi &lt; 20 ms db file sequential read Read Synchronous Single &lt; 20 ms direct path read Read Asynchronous Multi &lt; 20 ms direct path read temp Read Asynchronous Multi &lt; 20 ms direct path write Write Asynchronous Multi &lt; 15 ms direct path write temp Write Asynchronous Multi &lt; 15 ms log file parallel write Write Asynchronous Multi &lt; 15 ms 确定响应时间的途径 10046 trace file 当在10046 trace中使用level 8或12时，会包含相关的等待事件的信息，响应时间是ela字段，单位是微秒。 WAIT #5: nam='cell single block physical read' ela= 672 cellhash#=2520626383 diskhash#=1377492511 bytes=16384 obj#=63 tim=1280416903276618 &gt;&gt; 672 microseconds = 0.672 ms WAIT #5: nam='db file sequential read' ela= 1018 file#=2 block#=558091 blocks=1 obj#=0 tim=10191852599110 &gt;&gt; 1018 microseconds =&gt; 1.018 ms System State Dump 对于每个系统级的进程，等待信息包括在进程信息中。通常显示一个活动的waiting for，或者等待完成，进程正在CPU中执行waited for/last wait for。 其中waiting for表示进程处于等待状态。11g之前可以查看seconds since wait started字段，显示进程已经等待多久了。从11gR1开始，”total“字段显示等待的时间。 如果waiting for显示一个进程正在等待一个IO相关的操作，seconds since wait started&gt;0，表示可能IO丢失，session处于hang状态。(因为之前提到过平均可接受时间是20毫秒，任何IO等待时间超过1秒都需要关注)。 last wait for是与11g之前的版本相关的，表明进程不在等待(例如正在使用CPU)。等待时间记录到”wait_time“字段。(11g中wait_time被not in wait替代) last wait for 'db file sequential read' blocking sess=0x0 seq=100 wait_time=2264 seconds since wait started=0 file#=45, block#=17a57, blocks=1 &gt;&gt; 2264 microseconds =&gt; 2.264 ms waited for表示session不在等待。通常是11gR1以后的系统级trace中使用。total字段表示等待的总时间。 0: waited for 'db file sequential read' file#=9, block#=46526, blocks=1 wait_id=179 seq_num=180 snap_id=1 wait times: snap=0.007039 sec, exc=0.007039 sec, total=0.007039 sec wait times: max=infinite wait counts: calls=0 os=0 &gt;&gt; 0.007039 sec =&gt; 7.039 ms Statspack 与AWR reports 前台进程和后台进程的等待事件，平均响应时间通过Wait Avg(ms)反映(以毫秒计算的平均读)。 表空间IO 平均响应时间通过Av Rd (ms)反映(以毫秒计算的平均读)。 等待事件直方图可以提供组成这些平均值的写操作时间分布。他会展示出所有写操作都接近于平均值，还是会有若干波峰或波谷的情况。每列都表明每个bucket之间等待事件时间分布的百分比。例如，&lt;16ms的等待大于&lt;8ms。只要最大的百分比是从&lt;1ms到16ms的范围内，那么IO性能通常就可以接受。 4. 总结 本文的目标不是为了排查IO变慢的原因，而是为了如何寻找判定IO慢的证据。如果性能变差，那么IO慢可能成为性能问题的一个潜在原因，需要从数据库角度来分析如何采集支持的证据；如果潜在原因是由于操作系统级别的IO慢，那么负责IO子系统工程师需要参与进来诊断和修复这个问题。 ","link":"https://hkxtor.github.io/vQKm4MfiK/"}]}