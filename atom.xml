<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hkxtor.github.io</id>
    <title>老黄的养生会所</title>
    <updated>2021-02-07T03:31:49.566Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hkxtor.github.io"/>
    <link rel="self" href="https://hkxtor.github.io/atom.xml"/>
    <subtitle>宁可孤独，也不违心。不入我心者，不屑以敷衍。</subtitle>
    <logo>https://hkxtor.github.io/images/avatar.png</logo>
    <icon>https://hkxtor.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 老黄的养生会所</rights>
    <entry>
        <title type="html"><![CDATA[19C pdb开启awr以获取数据文件等io信息]]></title>
        <id>https://hkxtor.github.io/k8frSam77/</id>
        <link href="https://hkxtor.github.io/k8frSam77/">
        </link>
        <updated>2021-02-07T03:30:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="现象">现象</h1>
<pre><code class="language-sql">sqlplus / as sysdba

SQL*Plus: Release 19.0.0.0.0 - Production on Sun Jan 24 12:50:58 2021
Version 19.10.0.0.0

Copyright (c) 1982, 2020, Oracle.  All rights reserved.


Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0

SQL&gt; show pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
         2 PDB$SEED                       READ ONLY  NO
         3 HKXTOR                         READ WRITE NO
         4 SJZX                           READ WRITE NO
SQL&gt; alter session set container=hkxtor
  2  ;

Session altered.

SQL&gt; show con_name

CON_NAME
------------------------------
HKXTOR

SQL&gt; @?/rdbms/admin/awrrpt.sql

Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
AWR reports can be generated in the following formats.  Please enter the
name of the format at the prompt.  Default value is 'html'.

'html'          HTML format (default)
'text'          Text format
'active-html'   Includes Performance Hub active report

Enter value for report_type:
old   1: select 'Type Specified: ',lower(nvl('&amp;&amp;report_type','html')) report_type from dual
new   1: select 'Type Specified: ',lower(nvl('','html')) report_type from dual

Type Specified:                                  html



Specify the location of AWR Data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AWR_ROOT - Use AWR data from root (default)
AWR_PDB - Use AWR data from PDB
Enter value for awr_location: AWR_PDB

Location of AWR Data Specified:
AWR_PDB





Current Instance
~~~~~~~~~~~~~~~~
DB Id          DB Name        Inst Num       Instance       Container Name
-------------- -------------- -------------- -------------- --------------
 3516530670     CDB                        1 cdb           HKXTOR



Root DB Id      Container DB Id AWR DB Id
--------------- --------------- ---------------
    299079762      3516530670      3516530670






Instances in this Workload Repository schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using 3516530670 for database Id
Using          1 for instance number
declare
*
ERROR at line 1:
ORA-20200: Database/Instance 3516530670/1 does not exist in
AWR_PDB_DATABASE_INSTANCE
ORA-06512: at line 27


Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0
</code></pre>
<h1 id="mos">MOS:</h1>
<p>ORA-20200 Error When Generating AWR or ADDM Report as a PDB DBA User From a 12.2.0.1 and higher CDB Database (Doc ID 2267849.1)<br>
Bug 25941188 - ORA-20200 WHEN ADDM REPORT GENERATED FROM A PDB DATABASE USING AWR_PDB OPTION &lt;==closed as duplicate to following internal bug that is still being worked on:<br>
Bug 27747951 : CDB_MA: ADDMRPT.SQL EXECUTION IN PDB LEVEL</p>
<h1 id="解决办法">解决办法：</h1>
<pre><code>ALTER SYSTEM SET awr_pdb_autoflush_enabled= TRUE SID='*' SCOPE=BOTH;
ALTER SYSTEM SET awr_snapshot_time_offset=1000000 SID='*' SCOPE=BOTH;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RushQL勒索病毒的处理]]></title>
        <id>https://hkxtor.github.io/ihIcEuWzN/</id>
        <link href="https://hkxtor.github.io/ihIcEuWzN/">
        </link>
        <updated>2020-08-20T09:01:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rushql病毒简介">RushQL病毒简介</h1>
<p>RushQL专门针对Oracle数据库设计、具备一定潜伏期和隐蔽性的勒索病毒，该病毒是由“SQL RUSH Team”组织发起，最早于2016年11月出现，其主要感染方式是将破解版或绿色版的PL/SQL中的login.sql和Afterconnect.sql脚本篡改，所以在使用前需检查这两个脚本，若其大小不为零，则很有可能已被篡改。运行被篡改后的脚本会在数据库中增加下列存储过程和触发器：</p>
<pre><code class="language-sql">存储过程：
DBMS_SUPPORT_INTERNAL
DBMS_STANDARD_FUN9
DBMS_SYSTEM_INTERNA
DBMS_CORE_INTERNAL
触发器：
DBMS_SUPPORT_INTERNAL
DBMS_SYSTEM_INTERNAL
DBMS_CORE_INTERNAL
</code></pre>
<h1 id="中毒表现">中毒表现</h1>
<p>RushQL病毒感染Oracle数据库后，先判断数据库的创建时长是否达到1200天，若不满足此条件，则会一直潜伏，满足条件后再爆发。爆发后，用户使用客户端连接数据库或者数据库Alert日志中出现ORA-20312/ORA-20313/ORA-20315等报错信息，描述数据库已被锁死，需要发送比特币到某个地址来解锁数据库。</p>
<pre><code class="language-sql">Errors in file /oracle/diag/rdbms/liantiaodb/liantiaodb/trace/liantiaodb_ora_5213.trc:
ORA-00604: 递归 SQL 级别 1 出现错误
ORA-20315: 你的数据库已被SQL RUSH Team锁死 发送5个比特币到这个地址 166xk1FXMB2g8JxBVF5T4Aw1Z5JaZ6vrSE (大小写一致) 之后把你的Oracle SID邮寄地址 sqlrush@mail.com 我们将让你知道如何解锁你的数据库 Hi buddy, your database was hacked by SQL RUSH Team, send 5 bitcoin to address 166xk1FXMB2g8JxBVF5T4Aw1Z5JaZ6vrSE (case sensitive), after that send your Oracle SID to mail address sqlrush@mail.com, we will let you know how to unlock your database.
ORA-06512: 在 &quot;AIQRY.DBMS_CORE_INTERNAL &quot;, line 25
ORA-06512: 在 line 2
</code></pre>
<h1 id="病毒检测">病毒检测</h1>
<p>已中毒的Oracle数据库中会多出上述存储过程和触发器，且该病毒的制作者非常狡猾的在上述存储过程和触发器的名字中加入了多个空格，导致其无法被查询到和被删除，因此，在进行查询和删除时要加入通配符：</p>
<pre><code class="language-sql">SELECT owner,created,object_name,object_type FROM dba_objects WHERE object_name LIKE '%DBMS_SUPPORT%';
SELECT owner,created,object_name,object_type FROM dba_objects WHERE object_name LIKE '%DBMS_SYSTEM_INTERNAL%';
SELECT owner,created,object_name,object_type FROM dba_objects WHERE object_name LIKE '%DBMS_CORE_INTERNAL%';
SELECT owner,created,object_name,object_type FROM dba_objects WHERE object_name LIKE '%DBMS_STANDARD_FUN9%';
</code></pre>
<p>未爆发的数据库中可以检测到上述存储过程和触发器，已爆发的数据库中除了能检测到上述存储过程和触发器，还会存在很多truncate jobs，产生非常多的日志，导致数据库空间被大量占用，最终将数据库目录被挤爆，数据库服务中断。</p>
<pre><code class="language-sql">SELECT COUNT(*) FROM dba_jobs WHERE schema_user='username' AND what LIKE '%truncate%';
username为上述查询结果中的owner
</code></pre>
<h1 id="病毒处理">病毒处理</h1>
<p>参考：https://blogs.oracle.com/cnsupport_news/%e5%af%b9%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e2%80%9c%e6%af%94%e7%89%b9%e5%b8%81%e6%94%bb%e5%87%bb%e2%80%9d%e5%8f%8a%e9%98%b2%e6%8a%a4<br>
删除上述存储过程和触发器：</p>
<pre><code class="language-sql">DROP PROCEDURE %DBMS_SUPPORT_INTERNAL%;
DROP PROCEDURE %DBMS_STANDARD_FUN9%;
DROP PROCEDURE %DBMS_SYSTEM_INTERNA%;
DROP PROCEDURE %DBMS_CORE_INTERNAL%;
DROP TRIGGER %DBMS_SUPPORT_INTERNAL%;
DROP TRIGGER %DBMS_SYSTEM_INTERNAL%;
DROP TRIGGER %DBMS_CORE_INTERNAL%;
</code></pre>
<p>删除异常的jobs：</p>
<pre><code class="language-sql">DELETE FROM dba_jobs WHERE schema_user='username' AND what LIKE '%truncate%';
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[clickhouse installation on centos 7.8]]></title>
        <id>https://hkxtor.github.io/t-ZQVW9TS/</id>
        <link href="https://hkxtor.github.io/t-ZQVW9TS/">
        </link>
        <updated>2020-06-02T07:54:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="系统检查">系统检查</h2>
<pre><code># grep -q sse4_2 /proc/cpuinfo &amp;&amp; echo &quot;SSE 4.2 supported&quot; || echo &quot;SSE 4.2 not supported&quot;
SSE 4.2 supported
</code></pre>
<h2 id="rpm包安装">RPM包安装</h2>
<pre><code>建议对CentOS，RedHat和所有其他基于rpm的Linux发行版使用官方的预编译rpm软件包。
sudo yum install yum-utils
sudo rpm --import https://repo.clickhouse.tech/CLICKHOUSE-KEY.GPG
sudo yum-config-manager --add-repo https://repo.clickhouse.tech/rpm/stable/x86_64
</code></pre>
<h2 id="启动">启动</h2>
<pre><code>systemctl daemon-reload
systemctl start clickhouse-server.service
# systemctl status clickhouse-server.service 
● clickhouse-server.service - ClickHouse Server (analytic DBMS for big data)
Loaded: loaded (/etc/systemd/system/clickhouse-server.service; enabled; vendor preset: disabled)
Active: active (running) since Tue 2020-06-02 15:45:22 CST; 8s ago
Main PID: 13949 (clickhouse-serv)
    Tasks: 44
Memory: 163.9M
CGroup: /system.slice/clickhouse-server.service
        └─13949 /usr/bin/clickhouse-server --config=/etc/clickhouse-server/config.xml --pid-file=/run/clickhouse-server/clickhouse-server.pid

Jun 02 15:45:22 hqcentos clickhouse-server[13949]: Include not found: clickhouse_compression
Jun 02 15:45:22 hqcentos clickhouse-server[13949]: Logging trace to /var/log/clickhouse-server/clickhouse-server.log
Jun 02 15:45:22 hqcentos clickhouse-server[13949]: Logging errors to /var/log/clickhouse-server/clickhouse-server.err.log
Jun 02 15:45:28 hqcentos clickhouse-server[13949]: Processing configuration file '/etc/clickhouse-server/users.xml'.
Jun 02 15:45:28 hqcentos clickhouse-server[13949]: Include not found: networks
Jun 02 15:45:28 hqcentos clickhouse-server[13949]: Saved preprocessed configuration to '/var/lib/clickhouse//preprocessed_configs/users.xml'.
Jun 02 15:45:30 hqcentos clickhouse-server[13949]: Processing configuration file '/etc/clickhouse-server/config.xml'.
Jun 02 15:45:30 hqcentos clickhouse-server[13949]: Include not found: clickhouse_remote_servers
Jun 02 15:45:30 hqcentos clickhouse-server[13949]: Include not found: clickhouse_compression
Jun 02 15:45:30 hqcentos clickhouse-server[13949]: Saved preprocessed configuration to '/var/lib/clickhouse//preprocessed_configs/config.xml'.
</code></pre>
<h2 id="登录">登录</h2>
<pre><code># clickhouse-client 
ClickHouse client version 20.4.4.18 (official build).
Connecting to localhost:9000 as user default.
Connected to ClickHouse server version 20.4.4 revision 54434.

hqcentos :) select 1;

SELECT 1

┌─1─┐
│ 1 │
└───┘

1 rows in set. Elapsed: 0.002 sec. 

hqcentos :) 
</code></pre>
<p>简单的安装配置到此结束</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Oracle rman恢复遇到Error validating file dummy (36) in piece xxx: missing header]]></title>
        <id>https://hkxtor.github.io/DAs8G2vZY/</id>
        <link href="https://hkxtor.github.io/DAs8G2vZY/">
        </link>
        <updated>2020-05-14T03:22:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="过程">过程</h1>
<p>用参数拉起实例后，还原控制文件，数据库拉起到mount状态，catalog start with xx注册备份文件。</p>
<h1 id="现象">现象</h1>
<p>执行catalog start with xx后，alert日志出现以下信息</p>
<pre><code>Thu May 14 11:18:24 2020
Setting recovery target incarnation to 2
Setting recovery target incarnation to 2
Error validating file dummy (14) in piece xxx: missing header
Expanded controlfile section 14 from 245 to 490 records
Requested to grow by 245 recards; added 3 blocks of records
</code></pre>
<p>执行还原脚本出现以下报错后退出</p>
<pre><code>ORA-01180: can not create datafile 1
ORA-01110: data file 1:  '+DATA/xxxx/datafile/system01.dbf'
</code></pre>
<h1 id="解决过程">解决过程</h1>
<p>rman中查看incarnation</p>
<pre><code>RMAN&gt; list incarnation;

List of Database Incarnations
DB Key  Inc Key DB Name  DB ID            STATUS Reset SCN  Reset Time
------- ------- -------- ---------------- ------ ------------------ ----------
1       1       ORCL     1446008355       PARENT   1                2014/12/26 14:31:00
2       2       ORCL     1446008355       CURRENT  17034938503292   2020/05/09 17:34:36
</code></pre>
<p>重置incarnation回1</p>
<pre><code>RMAN&gt; reset database to incarnation 1;
database reset to incatnation 1

RMAN&gt; list incarnation;

List of Database Incarnations
DB Key  Inc Key DB Name  DB ID            STATUS Reset SCN  Reset Time
------- ------- -------- ---------------- ------ ------------------ ----------
1       1       ORCL     1446008355       CURRENT   1               2014/12/26 14:31:00
2       2       ORCL     1446008355       ORPHAN  17034938503292    2020/05/09 17:34:36
</code></pre>
<p>观察alert日志</p>
<pre><code>Thu May 14 11:21:28 2020
Setting recovery target incarnation to 1
</code></pre>
<p>在执行还原脚本，还原成功</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql无损/半同步复制]]></title>
        <id>https://hkxtor.github.io/BwozcZWlU/</id>
        <link href="https://hkxtor.github.io/BwozcZWlU/">
        </link>
        <updated>2020-04-28T11:34:45.000Z</updated>
        <content type="html"><![CDATA[<p>1.参数文件里加</p>
<pre><code>plugin_dir=/usr/local/mysql/lib/plugin
plugin_load = &quot;rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so&quot;
loose_rpl_semi_sync_master_enabled = 1
loose_rpl_semi_sync_slave_enabled = 1
loose_rpl_semi_sync_master_timeout = 5000
</code></pre>
<p>2.主库准备步骤</p>
<pre><code>grant replication slave, replication client on *.* to rep@'192.168.56.%' identified by '123456';
flush privileges;
mysql&gt; show master status;
+------------+----------+--------------+------------------+----------------------------------------------+
| File       | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                            |
+------------+----------+--------------+------------------+----------------------------------------------+
| bin.000007 | 57566891 |              |                  | 35d3ad22-8862-11ea-97a1-080027bb5279:1-43998 |
+------------+----------+--------------+------------------+----------------------------------------------+
</code></pre>
<p>3.备库准备步骤</p>
<pre><code>change master to master_host='192.168.56.101',master_user='rep',master_password='123456',master_log_file='bin.000007', master_log_pos=57566891,master_port = 3306;
</code></pre>
<p>4.测试</p>
<pre><code># 主库执行
mysql&gt; show variables like '%rpl%';  
+-------------------------------------------+------------+
| Variable_name                             | Value      |
+-------------------------------------------+------------+
| rpl_semi_sync_master_enabled              | ON         |
| rpl_semi_sync_master_timeout              | 5000       |
| rpl_semi_sync_master_trace_level          | 32         |
| rpl_semi_sync_master_wait_for_slave_count | 1          |
| rpl_semi_sync_master_wait_no_slave        | ON         |
| rpl_semi_sync_master_wait_point           | AFTER_SYNC |
| rpl_semi_sync_slave_enabled               | ON         |
| rpl_semi_sync_slave_trace_level           | 32         |
| rpl_stop_slave_timeout                    | 31536000   |
+-------------------------------------------+------------+
9 rows in set (0.00 sec)

mysql&gt; show global status like &quot;%rpl%&quot;;
+--------------------------------------------+-------+
| Variable_name                              | Value |
+--------------------------------------------+-------+
| Rpl_semi_sync_master_clients               | 1     |
| Rpl_semi_sync_master_net_avg_wait_time     | 0     |
| Rpl_semi_sync_master_net_wait_time         | 0     |
| Rpl_semi_sync_master_net_waits             | 0     |
| Rpl_semi_sync_master_no_times              | 1     |
| Rpl_semi_sync_master_no_tx                 | 2     |
| Rpl_semi_sync_master_status                | ON    |
| Rpl_semi_sync_master_timefunc_failures     | 0     |
| Rpl_semi_sync_master_tx_avg_wait_time      | 0     |
| Rpl_semi_sync_master_tx_wait_time          | 0     |
| Rpl_semi_sync_master_tx_waits              | 0     |
| Rpl_semi_sync_master_wait_pos_backtraverse | 0     |
| Rpl_semi_sync_master_wait_sessions         | 0     |
| Rpl_semi_sync_master_yes_tx                | 0     |
| Rpl_semi_sync_slave_status                 | OFF   |
+--------------------------------------------+-------+
15 rows in set (0.00 sec)

# 从库执行
mysql&gt; show global variables like '%semi%';
+-------------------------------------------+------------+
| Variable_name                             | Value      |
+-------------------------------------------+------------+
| rpl_semi_sync_master_enabled              | ON         |
| rpl_semi_sync_master_timeout              | 5000       |
| rpl_semi_sync_master_trace_level          | 32         |
| rpl_semi_sync_master_wait_for_slave_count | 1          |
| rpl_semi_sync_master_wait_no_slave        | ON         |
| rpl_semi_sync_master_wait_point           | AFTER_SYNC |
| rpl_semi_sync_slave_enabled               | ON         |
| rpl_semi_sync_slave_trace_level           | 32         |
+-------------------------------------------+------------+
8 rows in set (0.00 sec)

mysql&gt; stop slave io_thread;
Query OK, 0 rows affected (0.00 sec)

# 主库执行
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql&gt; create database test;
Query OK, 1 row affected (5.00 sec) ---(rpl_semi_sync_master_timeout设置的5秒超时)

mysql&gt; show global status like &quot;%rpl%&quot;;
+--------------------------------------------+-------+
| Variable_name                              | Value |
+--------------------------------------------+-------+
| Rpl_semi_sync_master_clients               | 0     |
| Rpl_semi_sync_master_net_avg_wait_time     | 0     |
| Rpl_semi_sync_master_net_wait_time         | 0     |
| Rpl_semi_sync_master_net_waits             | 0     |
| Rpl_semi_sync_master_no_times              | 2     |
| Rpl_semi_sync_master_no_tx                 | 3     |
| Rpl_semi_sync_master_status                | OFF   |
| Rpl_semi_sync_master_timefunc_failures     | 0     |
| Rpl_semi_sync_master_tx_avg_wait_time      | 0     |
| Rpl_semi_sync_master_tx_wait_time          | 0     |
| Rpl_semi_sync_master_tx_waits              | 0     |
| Rpl_semi_sync_master_wait_pos_backtraverse | 0     |
| Rpl_semi_sync_master_wait_sessions         | 0     |
| Rpl_semi_sync_master_yes_tx                | 0     |
| Rpl_semi_sync_slave_status                 | OFF   |
+--------------------------------------------+-------+
15 rows in set (0.00 sec)

# 从库执行
start slave io_thread;

# 主库执行
mysql&gt; show global status like &quot;%rpl%&quot;;
+--------------------------------------------+-------+
| Variable_name                              | Value |
+--------------------------------------------+-------+
| Rpl_semi_sync_master_clients               | 1     |
| Rpl_semi_sync_master_net_avg_wait_time     | 0     |
| Rpl_semi_sync_master_net_wait_time         | 0     |
| Rpl_semi_sync_master_net_waits             | 1     |
| Rpl_semi_sync_master_no_times              | 2     |
| Rpl_semi_sync_master_no_tx                 | 3     |
| Rpl_semi_sync_master_status                | ON    |
| Rpl_semi_sync_master_timefunc_failures     | 0     |
| Rpl_semi_sync_master_tx_avg_wait_time      | 0     |
| Rpl_semi_sync_master_tx_wait_time          | 0     |
| Rpl_semi_sync_master_tx_waits              | 0     |
| Rpl_semi_sync_master_wait_pos_backtraverse | 0     |
| Rpl_semi_sync_master_wait_sessions         | 0     |
| Rpl_semi_sync_master_yes_tx                | 0     |
| Rpl_semi_sync_slave_status                 | OFF   |
+--------------------------------------------+-------+
15 rows in set (0.00 sec)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL自带的性能压力测试工具mysqlslap]]></title>
        <id>https://hkxtor.github.io/DQakzE_dy/</id>
        <link href="https://hkxtor.github.io/DQakzE_dy/">
        </link>
        <updated>2020-04-28T10:30:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code>--only-print 只打印测试语句而不实际执行。
--detach=N 执行N条语句后断开重连。

# 单线程测试。测试做了什么。
mysqlslap -a -uroot -p123456
 
# 多线程测试。使用–concurrency来模拟并发连接。
mysqlslap -a -c 100 -uroot -p123456
 
# 迭代测试。用于需要多次执行测试得到平均值。
mysqlslap -a -i 10 -uroot -p123456
 
mysqlslap --auto-generate-sql-add-autoincrement -a -uroot -p123456
mysqlslap -a --auto-generate-sql-load-type=mixed -uroot -p123456
mysqlslap -a --auto-generate-sql-secondary-indexes=3 -uroot -p123456
mysqlslap -a --auto-generate-sql-write-number=1000 -uroot -p123456
mysqlslap --create-schema world -q &quot;select count(*) from City&quot; -uroot -p123456
mysqlslap -a -e innodb -uroot -p123456
mysqlslap -a --number-of-queries=10 -uroot -p123456
 
# 测试同时不同的存储引擎的性能进行对比：
mysqlslap -a --concurrency=50,100 --number-of-queries 1000 --iterations=5 --engine=myisam,innodb --debug-info -uroot -p123456
 
# 500和1000个并发分别得到一次测试结果(Benchmark)，并发数越多，执行完所有查询的时间越长。为了准确起见，可以多测试几次:
mysqlslap -a --concurrency=500,1000 --auto-generate-sql-add-autoincrement --auto-generate-sql-secondary-indexes=10 --number-of-queries 2000 --iterations=5

Benchmark
        Average number of seconds to run all queries: 1.551 seconds
        Minimum number of seconds to run all queries: 1.441 seconds
        Maximum number of seconds to run all queries: 1.716 seconds
        Number of clients running queries: 500
        Average number of queries per client: 4

Benchmark
        Average number of seconds to run all queries: 1.734 seconds
        Minimum number of seconds to run all queries: 1.589 seconds
        Maximum number of seconds to run all queries: 1.911 seconds
        Number of clients running queries: 1000
        Average number of queries per client: 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 长事务处理]]></title>
        <id>https://hkxtor.github.io/0k4Pjffz5/</id>
        <link href="https://hkxtor.github.io/0k4Pjffz5/">
        </link>
        <updated>2019-06-26T09:01:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-背景">1. 背景</h1>
<pre><code>1. 某个SQL执行特别慢，导致整个transaction一直处于running阶段
2. 某个Session的SQL已经执行完了，但是迟迟没有commit，一直处于sleep阶段
3. 某个Session处于lock wait阶段，迟迟没有结束
4. 以上，大部分原因都是大事务导致的，怎么处理呢
</code></pre>
<h1 id="2-大事务的特征">2. 大事务的特征</h1>
<pre><code>1. transaction开启到结束的时间非常长
2. 正在执行的事务
3. 未提交的事务
</code></pre>
<h2 id="21-监控那些正在执行的事务">2.1 监控那些正在执行的事务</h2>
<pre><code class="language-sql">select * from sys.processlist;
show processlist;
select * from information_schema.processlist;
select * from sys.session;
select * from information_schema.innodb_trx;
select * from performance_schema.events_statements_current;
</code></pre>
<h2 id="22-如何监控那些未提交的事务">2.2 如何监控那些未提交的事务</h2>
<pre><code class="language-sql">select * from information_schema.innodb_trx

如何两者结合

select trx_id,INNODB_TRX.trx_state,INNODB_TRX.trx_started,se.conn_id as processlist_id,trx_lock_memory_bytes,se.user,se.command,se.state,se.current_statement,se.last_statement from information_schema.INNODB_TRX,sys.session as se where trx_mysql_thread_id=conn_id;
+---------+-----------+---------------------+----------------+-----------------------+------+---------+----------+-------------------------------------+-------------------------------------+
| trx_id  | trx_state | trx_started         | processlist_id | trx_lock_memory_bytes | user | command | state    | current_statement                   | last_statement                      |
+---------+-----------+---------------------+----------------+-----------------------+------+---------+----------+-------------------------------------+-------------------------------------+
| 1592104 | LOCK WAIT | 2019-06-26 11:51:17 |              3 |                  1136 | NULL | Query   | updating | update test_1 set id=4 where id = 1 | NULL                                |
| 1592100 | RUNNING   | 2019-06-26 11:49:08 |              2 |                  1136 | NULL | Sleep   | NULL     | NULL                                | update test_1 set id=3 where id = 1 |
+---------+-----------+---------------------+----------------+-----------------------+------+---------+----------+-------------------------------------+-------------------------------------+
</code></pre>
<h1 id="3-如何快速解决锁等待问题">3. 如何快速解决锁等待问题</h1>
<pre><code class="language-sql">mysql:sys&gt; select * from sys.innodb_lock_waits\G
*************************** 1. row ***************************
                wait_started: 2019-06-26 11:49:58
                    wait_age: 00:00:03
               wait_age_secs: 3
                locked_table: `test`.`test_1`
                locked_index: GEN_CLUST_INDEX
                 locked_type: RECORD
              waiting_trx_id: 1592102
         waiting_trx_started: 2019-06-26 11:49:58
             waiting_trx_age: 00:00:03
     waiting_trx_rows_locked: 2
   waiting_trx_rows_modified: 0
                 waiting_pid: 3
               waiting_query: update test_1 set id=4 where id = 1
             waiting_lock_id: 1592102:32:3:4
           waiting_lock_mode: X
             blocking_trx_id: 1592100
                blocking_pid: 2
              blocking_query: NULL
            blocking_lock_id: 1592100:32:3:4
          blocking_lock_mode: X
        blocking_trx_started: 2019-06-26 11:49:08
            blocking_trx_age: 00:00:53
    blocking_trx_rows_locked: 1
  blocking_trx_rows_modified: 1
     sql_kill_blocking_query: KILL QUERY 2
sql_kill_blocking_connection: KILL 2

MySQL连kill SQL 语句都提供了

通过innodb_lock_waits你只能看到被lock的语句，但是看不到是哪个query语句拥有的锁，如果幸运的话，可以看到上述的案例中 current_statement，last_statement 得到答案。
即便没有找到那条query，也不妨碍你解决当前的问题哈
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[11.2单机数据库转换为RAC -- 使用rconfig]]></title>
        <id>https://hkxtor.github.io/eP0H2Pm3z/</id>
        <link href="https://hkxtor.github.io/eP0H2Pm3z/">
        </link>
        <updated>2018-11-06T03:04:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>rconfig的功能除了单机转换为RAC，还可以单机转换为Standalone，Standalone转换为RAC，RAC转换为Standalone等等。</p>
<h1 id="配置文件">配置文件</h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;n:RConfig xmlns:n=&quot;http://www.oracle.com/rconfig&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xsi:schemaLocation=&quot;http://www.oracle.com/rconfig rconfig.xsd&quot;&gt;
    &lt;n:ConvertToRAC&gt;   
&lt;!-- Verify does a precheck to ensure all pre-requisites are met, before the conversion is attempted. Allowable values are: YES|NO|ONLY --&gt;
        &lt;n:Convert verify=&quot;YES&quot;&gt;
&lt;!--Specify current OracleHome of non-rac database for SourceDBHome --&gt;
              &lt;n:SourceDBHome&gt;/u01/app/oracle/product/11.2.0/db_1&lt;/n:SourceDBHome&gt;
&lt;!--Specify OracleHome where the rac database should be configured. It can be same as SourceDBHome --&gt;
              &lt;n:TargetDBHome&gt;/u01/app/oracle/product/11.2.0/db_1&lt;/n:TargetDBHome&gt;
&lt;!--Specify SID of non-rac database and credential. User with sysdba role is required to perform conversion --&gt;
              &lt;n:SourceDBInfo SID=&quot;test&quot;&gt;
                &lt;n:Credentials&gt;
                  &lt;n:User&gt;sys&lt;/n:User&gt;
                  &lt;n:Password&gt;Oracle123&lt;/n:Password&gt;
                  &lt;n:Role&gt;sysdba&lt;/n:Role&gt;
                &lt;/n:Credentials&gt;
              &lt;/n:SourceDBInfo&gt;
&lt;!--Specify the list of nodes that should have rac instances running for the Admin Managed Cluster Database. LocalNode should be the first node in this nodelist. --&gt;
              &lt;n:NodeList&gt;        
                &lt;n:Node name=&quot;rac1&quot;/&gt;
                &lt;n:Node name=&quot;rac2&quot;/&gt;
              &lt;/n:NodeList&gt;
&lt;!--Specify RacOneNode along with servicename to convert database to RACOne Node --&gt;
              &lt;!--n:RacOneNode  servicename=&quot;salestestservice&quot;/--&gt;
&lt;!--Instance Prefix tag is optional starting with 11.2. If left empty, it is derived from db_unique_name.--&gt;
              &lt;n:InstancePrefix&gt;test&lt;/n:InstancePrefix&gt;
&lt;!-- Listener details are no longer needed starting 11.2. Database is registered with default listener and SCAN listener running from Oracle Grid Infrastructure home. --&gt;
&lt;!--Specify the type of storage to be used by rac database. Allowable values are CFS|ASM. The non-rac database should have same storage type. ASM credentials are no needed for conversion. --&gt;
              &lt;n:SharedStorage type=&quot;ASM&quot;&gt;
&lt;!--Specify Database Area Location to be configured for rac database.If this field is left empty, current storage will be used for rac database. For CFS, this field will have directory path. --&gt;
                &lt;n:TargetDatabaseArea&gt;+DATADG1&lt;/n:TargetDatabaseArea&gt;  # 如果已经转成使用asm，则留空，否则会使用rman进行backup as copy database的操作，消耗更多空间
&lt;!--Specify Fast Recovery Area to be configured for rac database. If this field is left empty, current recovery area of non-rac database will be configured for rac database. If current database is not using recovery Area, the resulting rac database will not have a recovery area. --&gt;
                &lt;n:TargetFlashRecoveryArea&gt;+DATADG1&lt;/n:TargetFlashRecoveryArea&gt; # 如果已经转成使用asm，则留空，否则会使用rman进行backup as copy database的操作，消耗更多空间
              &lt;/n:SharedStorage&gt;
        &lt;/n:Convert&gt;
    &lt;/n:ConvertToRAC&gt;
&lt;/n:RConfig&gt;
</code></pre>
<h1 id="用法">用法</h1>
<pre><code>rconfig test.xml
</code></pre>
<h1 id="对应日志">对应日志</h1>
<pre><code>$ORACLE_BASE/cfgtoollogs/rconfig/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL体系结构与管理]]></title>
        <id>https://hkxtor.github.io/1VMe2UNvc/</id>
        <link href="https://hkxtor.github.io/1VMe2UNvc/">
        </link>
        <updated>2018-04-27T10:24:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1体系结构">1.体系结构</h1>
<h2 id="11-cs模型">1.1 C/S模型</h2>
<pre><code>TCP/IP方式（远程、本地）：
mysql -uroot -123456 -h 10.0.0.51 -P3306
Socket方式(仅本地)：
mysql -uroot -123456 -S /tmp/mysql.sock
</code></pre>
<h2 id="12-实例">1.2 实例</h2>
<pre><code>实例=mysqld后台守护进程+Master Thread +干活的Thread+预分配的内存
</code></pre>
<h2 id="13-mysqld">1.3 mysqld</h2>
<h3 id="131-mysqld程序结构">1.3.1 mysqld程序结构</h3>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/Hkxtor/picb/img/16956686-7824255ca53f23e5.png" alt="" loading="lazy"></figure>
<h4 id="1311-连接层">1.3.1.1 连接层</h4>
<pre><code>1.3.2.1 连接层
（1）提供连接协议：TCP/IP 、SOCKET
（2）提供验证：用户、密码，IP，SOCKET
（3）提供专用连接线程：接收用户SQL，返回结果
通过以下语句可以查看到连接线程基本情况
mysql&gt; show processlist;
</code></pre>
<h4 id="1312-sql层">1.3.1.2 SQL层</h4>
<pre><code>（1）接收上层传送的SQL语句
（2）语法验证模块：验证语句语法,是否满足SQL_MODE
（3）语义检查：判断SQL语句的类型
            DDL ：数据定义语言
            DCL ：数据控制语言
            DML ：数据操作语言
            DQL： 数据查询语言
（4）权限检查：用户对库表有没有权限
（5）解析器：对语句执行前,进行预处理，生成解析树(执行计划),说白了就是生成多种执行方案.
（6）优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划代价模型：资源（CPU IO MEM）的耗损评估性能好坏
（7）执行器：根据最优执行计划，执行SQL语句，产生执行结果执行结果：在磁盘的xxxx位置上
（8）提供查询缓存（默认是没开启的），会使用redis tair替代查询缓存功能
（9）提供日志记录（日志管理章节）：binlog，默认是没开启的。
</code></pre>
<h4 id="1313-存储引擎层">1.3.1.3 存储引擎层</h4>
<pre><code>负责根据SQL层执行的结果，从磁盘上拿数据。
将16进制的磁盘数据，交由SQL结构化化成表，由连接层的专用线程返回给用户。
</code></pre>
<h2 id="14-逻辑结构">1.4 逻辑结构</h2>
<h3 id="141-库">1.4.1 库</h3>
<pre><code>每一个库都有库名、库属性组成，库属性包括字符集、校对规则等等。
</code></pre>
<h3 id="142-表二维表">1.4.2 表（二维表）</h3>
<pre><code>每一张表都有表名、属性、列（列名）、列属性（数据类型、约束等等）、数据行（record）、元数据组成。
</code></pre>
<h2 id="15-物理结构">1.5 物理结构</h2>
<h3 id="151-库的物理存储结构">1.5.1 库的物理存储结构</h3>
<pre><code>每一个库的物理存储结构都是由文件系统的目录来存储的，一个库就是一个目录。
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.00 sec)

[root@mysql1 data]# ls -ltr
drwxr-x---. 2 mysql mysql       8192 Apr 27 16:36 performance_schema
drwxr-x---. 2 mysql mysql       4096 Apr 27 16:36 mysql
drwxr-x---. 2 mysql mysql       8192 Apr 27 16:36 sys
drwxr-x---. 2 mysql mysql         20 Apr 28 16:57 test
</code></pre>
<h3 id="152-表的物理存储结构">1.5.2 表的物理存储结构</h3>
<pre><code>MyISAM（一种引擎）的表：
-rw-r----- 1 mysql mysql   10816 Apr 18 11:37 user.frm
-rw-r----- 1 mysql mysql     396 Apr 18 12:20  user.MYD
-rw-r----- 1 mysql mysql    4096 Apr 18 14:48 user.MYI

InnoDB(默认的存储引擎)的表：
-rw-r----- 1 mysql mysql    8636 Apr 18 11:37 time_zone.frm
-rw-r----- 1 mysql mysql   98304 Apr 18 11:37 time_zone.ibd
time_zone.frm：存储列相关信息
time_zone.ibd：数据行+索引
</code></pre>
<h3 id="153-表的段-区-页">1.5.3 表的段、区、页</h3>
<pre><code>页：最小的存储单元，默认16k
区：64个连续的页，共1M
段：一个表就是一个段，包含一个或多个区
</code></pre>
<h1 id="2-基础管理">2. 基础管理</h1>
<h2 id="21-用户-权限管理">2.1 用户、权限管理</h2>
<h3 id="211-用户">2.1.1 用户</h3>
<p>作用：</p>
<pre><code>登录，管理数据库逻辑对象
</code></pre>
<p>定义：</p>
<pre><code>用户名@'白名单'
白名单支持的方式：
root@'%'			允许所有地址、域名
root@'192.0.0.%'	 	允许192.0.0.0/24
root@'192..0.0.200'  		只允许这个用记在200地址的这台机器上登录
root@'localhost'     		只能本地连接
root@'db01'	        	只能这个域名
root@'192.0.0.5%'     	        只能50-59ip的用户登录
root@'192.0.0.0/255.255.254.0'  只允许这个网段的子网掩码是254的用户登录
</code></pre>
<p>管理：</p>
<pre><code class="language-sql">增：
mysql&gt; create user hkxtor@'10.0.0.%' identified by '123';
查：
mysql&gt; desc mysql.user;    ----&gt;  authentication_string
mysql&gt; select user ,host ,authentication_string from mysql.user
改:
mysql&gt; alter user hkxtor@'10.0.0.%' identified by '456';
删：
mysql&gt; drop user hkxtor@'10.0.0.%';
</code></pre>
<h3 id="212-权限">2.1.2 权限</h3>
<p>权限介绍：</p>
<pre><code>相对于用户而言，用户所能访问只是权限的一部分功能，MySQL能精确针对用户修改用户对哪一个库或者哪一张表进行查询、修改、删除、创建权限，超级管理员还具备给别的用户进行用户授权的权限。
</code></pre>
<p>常用权限：</p>
<pre><code>ALL:
SELECT,INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE
ALL : 以上所有权限，一般是普通管理员拥有的
with grant option：超级管理员才具备的，给别的用户授权的功能
</code></pre>
<p>演示：</p>
<pre><code>create user hkxtor@'%' identified by '123';		创建用户以及设置访问区域及密码
grant all on test.*  to  hkxtor@'%';			赋予用户hkxtor所有区域进行访问库test的权限
show grants for hkxtor@'%';				查看用户所被赋予的权限
mysql [(none)]&gt;show grants for hkxtor@'%';
+--------------------------------------------------+
| Grants for hkxtor@%                              |
+--------------------------------------------------+
| GRANT USAGE ON *.* TO 'hkxtor'@'%'               |
| GRANT ALL PRIVILEGES ON `test`.* TO 'hkxtor'@'%' |
+--------------------------------------------------+
2 rows in set (0.01 sec)
revoke delete on test.* from 'hkxtor'@'%';		删除用户的delete权限
</code></pre>
<p>管理员忘记密码：</p>
<pre><code>[root@mysql1 ~]# mysqld_safe --skip-grant-tables --skip-networking &amp;  关闭用户密码的验证   关闭tcp/ip的远程连接
mysql&gt; flush privileges;
mysql&gt;  alter user root@'localhost' identified by '123456';
[root@mysql1 ~]# pkill mysqld
</code></pre>
<h2 id="22-连接管理">2.2 连接管理</h2>
<h3 id="221-自带客户端">2.2.1 自带客户端</h3>
<pre><code>[root@mysql1 ~]# mysql -uroot -p -h localhost -P3306
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 5.7.29-log MySQL Community Server (GPL)

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; select @@socket;
+-----------------+
| @@socket        |
+-----------------+
| /tmp/mysql.sock |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; ^DBye
[root@mysql1 ~]# 
[root@mysql1 ~]# mysql -uroot -p -S /tmp/mysql.sock
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 9
Server version: 5.7.29-log MySQL Community Server (GPL)

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; exit
Bye
[root@mysql1 ~]# mysql -uroot -p -e &quot;select user,host from mysql.user;&quot;
Enter password: 
+---------------+--------------+
| user          | host         |
+---------------+--------------+
| hkxtor        | %            |
| rep           | 192.168.56.% |
| mysql.session | localhost    |
| mysql.sys     | localhost    |
| root          | localhost    |
+---------------+--------------+
[root@mysql1 ~]# mysql -uroot -p &lt; all.sql #导入备份文件
Enter password:
</code></pre>
<h2 id="24-初始化配置">2.4 初始化配置</h2>
<h3 id="241-作用">2.4.1 作用</h3>
<pre><code>控制MySQL的启动，影响到客户端的连接，也就是直接在linux命令行操作的时候进行参数的添加
</code></pre>
<h3 id="242-初始化的方法">2.4.2 初始化的方法</h3>
<pre><code>预编译
**配置文件(所有启动方式)**
命令行参数 (仅限于 mysqld_safe mysqld)
</code></pre>
<h3 id="243-配置文件">2.4.3 配置文件</h3>
<p>默认路径：</p>
<pre><code>[root@db01 ~]# mysqld --help --verbose |grep my.cnf
/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf
注:
默认情况下，MySQL启动时，会依次读取以上配置文件，如果有重复选项，会以最后一个文件设置的为准。
但是，如果启动时加入了--defaults-file=xxxx时，以上的所有文件都不会读取.
</code></pre>
<p>配置文件格式：</p>
<pre><code>[标签]
配置项=xxxx

标签类型：服务端、客户端
服务器端标签：
[mysqld]
[mysqld_safe]
[server]

客户端标签：
[mysql]
[mysqldump]
[client]

配置文件的示例展示：
[root@db01 ~]# cat /etc/my.cnf
[mysqld]
user=mysql
basedir=/app/mysql
datadir=/data/mysql
socket=/tmp/mysql.sock
server_id=6
port=3306
log_error=/data/mysql/mysql.log
[mysql]
socket=/tmp/mysql.sock
prompt=Master [\\d]&gt;
</code></pre>
<h2 id="25-多实例">2.5 多实例</h2>
<h3 id="251-准备数据目录">2.5.1 准备数据目录</h3>
<pre><code>mkdir -p /data/330{7,8,9}/data
</code></pre>
<h3 id="252-准备配置文件">2.5.2 准备配置文件</h3>
<pre><code>cat &gt; /data/3307/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/app/mysql
datadir=/data/3307/data
socket=/data/3307/mysql.sock
log_error=/data/3307/mysql.log
port=3307
server_id=7
log_bin=/data/3307/mysql-bin
EOF

cat &gt; /data/3308/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/app/mysql
datadir=/data/3308/data
socket=/data/3308/mysql.sock
log_error=/data/3308/mysql.log
port=3308
server_id=8
log_bin=/data/3308/mysql-bin
EOF

cat &gt; /data/3309/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/app/mysql
datadir=/data/3309/data
socket=/data/3309/mysql.sock
log_error=/data/3309/mysql.log
port=3309
server_id=9
log_bin=/data/3309/mysql-bin
EOF
</code></pre>
<h3 id="253-分别初始化">2.5.3 分别初始化</h3>
<pre><code>mv /etc/my.cnf /etc/my.cnf.bak
mysqld --initialize-insecure  --user=mysql --datadir=/data/3307/data --basedir=/app/mysql
mysqld --initialize-insecure  --user=mysql --datadir=/data/3308/data --basedir=/app/mysql
mysqld --initialize-insecure  --user=mysql --datadir=/data/3309/data --basedir=/app/mysql
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12c可插拔数据库的几种克隆迁移方法]]></title>
        <id>https://hkxtor.github.io/qulIB3Rk0/</id>
        <link href="https://hkxtor.github.io/qulIB3Rk0/">
        </link>
        <updated>2017-11-30T03:03:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="oacle-多租户环境包含一个容器数据库cdb和零个或多个可插拔数据库pdb这种让数据库系统扩展也变得非常的灵活oracle-12c提供了许多种关于多租户模式下数据库的克隆迁移方式以下对于几种克隆迁移的方式进行实验介绍">Oacle 多租户环境包含一个容器数据库(CDB)和零个或多个可插拔数据库(PDB)，这种让数据库系统扩展也变得非常的灵活，oracle 12c提供了许多种关于多租户模式下数据库的克隆迁移方式，以下对于几种克隆迁移的方式进行实验介绍。</h3>
<h1 id="一通过现有pdb直接创建create-pluggable-databasefrom">一．通过现有PDB直接创建（CREATE PLUGGABLE DATABASE..FROM..）</h1>
<ol>
<li>
<p>从本地PDB创建</p>
<ol>
<li>
<p>克隆完整PDB</p>
<p>创建语句：</p>
<pre><code class="language-sql">CREATE PLUGGABLE DATABASE pdb3 FROM pdb2
    PATH_PREFIX = ' /u01/app/oracle/oradata/ ' --- 指定pdb相关联的目录，可以不设置
    FILE_NAME_CON VERT = (' /u01/app/oracle/oradata/orclcwd/pdb2/',   '/u01/app/oracle/oradata/orclcwd/pdb3/' ) - - 数据文件存放路径，在ASM中可以指定DG
    SERVICE_NAME_CONVERT = ('pdb2','pdb3') – 服务名转换
    NOLOGGING;


CREATE PLUGGABLE DATABASE pdb3 FROM pdb2
    PATH_PREFIX = '/u01/app/oracle/oradata/'
    FILE_NAME_CONVERT =   ('/u01/app/oracle/product/12.1.0/dbhome_1/dbs/u01/app/oracle/oradata/orclcwd/',   '/u01/app/oracle/oradata/orclcwd/pdb3/')
    SERVICE_NAME_CONVERT = ('pdb2','pdb3');
</code></pre>
<p>主要的选项说明：</p>
<p>PATH_PREFIX：将PDB的相对目录对象路径设置为特定目录。因此，需要设置PATH_PREFIX<br>
FILE_NAME_CONVERT：指定数据文件的转换路径<br>
Storage: 如果需要限制新建pdb的大小，可以使用storage=xxG 来限制。</p>
<p>创建的过程日志：</p>
<pre><code>CREATE PLUGGABLE DATABASE pdb3 FROM pdb2
    PATH_PREFIX = '/u01/app/oracle/oradata/'
    FILE_NAME_CONVERT =   ('/u01/app/oracle/product/12.1.0/dbhome_1/dbs/u01/app/oracle/oradata/orclcwd/',   '/u01/app/oracle/oradata/orclcwd/pdb3/')
SERVICE_NAME_CONVERT = ('pdb2','pdb3') &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 创建命令开始
Fri Aug 18 14:22:11 2017
Opatch XML is skipped for PDB PDB2 (conid=3) &lt;&lt;&lt;&lt;&lt; 跳过PDB2（源）Opatch   XML，看起来与版本检查有关
APEX_040200.WWV_FLOW_ADVISOR_CHECKS   (CHECK_STATEMENT) - CLOB populated
Fri Aug 18 14:24:15 2017 &lt;&lt;&lt;&lt; 开始创建新的PDB3，但此时的状态先为UNUSABLE
****************************************************************
Pluggable Database PDB3 with pdb id - 4 is   created as UNUSABLE.
If any errors are encountered before the pdb   is marked as NEW,
then the pdb must be dropped
****************************************************************
Database Characterset for PDB3 is ZHS16GBK &lt;&lt;&lt; 字符集检查
Fri Aug 18 14:24:26 2017 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 删除换旧的数据文件并生成新的数据文件
Deleting old file#8 from file$
Deleting old file#9 from file$
Adding new file#11 to file$(old file#8)
Adding new file#12 to file$(old file#9)
Successfully created internal service pdb3 at   open &lt;&lt;&lt;&lt;&lt;&lt; 创建服务成功
ALTER SYSTEM: Flushing buffer cache inst=0   container=4 local &lt;&lt;&lt;&lt;&lt; 刷新新PDB的buffer
****************************************************************
Post plug operations are now complete.  &lt;&lt;&lt;&lt;&lt; 插入PDB操作
Pluggable database PDB3 with pdb id - 4 is   now marked as NEW. &lt;&lt;&lt;&lt;PDB 状态定位NEW
****************************************************************
Completed: CREATE PLUGGABLE DATABASE pdb3   FROM pdb2 &lt;&lt;&lt;&lt; 完成
    PATH_PREFIX = '/u01/app/oracle/oradata/'
    FILE_NAME_CONVERT =   ('/u01/app/oracle/product/12.1.0/dbhome_1/dbs/u01/app/oracle/oradata/orclcwd/',   '/u01/app/oracle/oradata/orclcwd/pdb3/')
SERVICE_NAME_CONVERT = ('pdb2','pdb3')
</code></pre>
</li>
<li>
<p>仅克隆PDB元数据</p>
<p>有时并不需要克隆表里的数据，可使用NO DATA来克隆一个PDB，但仅仅克隆元数据。</p>
<p>以下示例：</p>
<ol>
<li>
<p>源PDB中表存在多行数据，这里特意选择了三种情况，看看是否NO DATA的机制如何：</p>
<ol>
<li>SYS 用户的表，表空间在SYSTEM</li>
<li>个人用户的表，表空间在SYSTEM</li>
<li>个人用户的表，表空间在普通表空间</li>
</ol>
</li>
<li>
<p>将源PDB打开到read only模式下：</p>
<pre><code>ALTER PLUGGABLE DATABASE pdb1 OPEN READ ONLY;
</code></pre>
</li>
<li>
<p>克隆PDB：</p>
<pre><code>CREATE PLUGGABLE DATABASE pdb4 FROM pdb3 NO DATA  FILE_NAME_CONVERT = ('/u01/app/oracle/oradata/orclcwd/pdb3/', '/u01/app/oracle/oradata/orclcwd/pdb4/');

SQL&gt; CREATE PLUGGABLE DATABASE   pdb4 FROM pdb3 NO DATA;
CREATE PLUGGABLE DATABASE pdb4 FROM pdb3 NO   DATA
                                            *
ERROR at line 1:
ORA-65016: FILE_NAME_CONVERT must be   specified

SQL&gt; CREATE PLUGGABLE DATABASE pdb4 FROM pdb3 NO DATA
    2    FILE_NAME_CONVERT = ('/u01/app/oracle/oradata/orclcwd/pdb3/','/u01/app/oracle/oradata/orclcwd/pdb4/');
Pluggable database created.
</code></pre>
</li>
<li>
<p>打开新克隆的PDB：</p>
<pre><code>ALTER PLUGGABLE DATABASE pdb4 OPEN;
</code></pre>
</li>
<li>
<p>到新的PDB下查询表数据：</p>
<p>从查询结果来看，使用NO DATA的方式克隆PDB时，SYSTEM表空间下的表数据是会克隆过去，但用户表空间下表数据库就仅克隆了元数据。</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>从远程PDB或non-CDB创建</p>
<p>通过远程方式创建克隆主要依靠的是dblink，因此需要源库和目标库之间网络保持畅通，而远处创建的方式和本地创建相差不大，远程模式可以增加从一个NON-CDB数据库克隆到CDB中。</p>
<ol>
<li>
<p>从PDB创建</p>
<ol>
<li>
<p>查看目标CDB当前情况：</p>
</li>
<li>
<p>在目标CDB创建连接远程CDB的dblink：</p>
<pre><code>SQL&gt; create   public database link cdb1 connect to system identified by &quot;111111&quot;   using 'cdb1';

Database link   created.
</code></pre>
</li>
<li>
<p>使用dblink远程创建</p>
<pre><code>SQL&gt;  CREATE PLUGGABLE DATABASE pdb5 FROM pdb4@cdb1
2      FILE_NAME_CONVERT = ('/u01/app/oracle/oradata/orclcwd/pdb4/','/u01/app/oracle/oradata/orclcwd/pdb5/');

Pluggable   database created.
</code></pre>
</li>
<li>
<p>完成创建：</p>
</li>
</ol>
</li>
<li>
<p>从NOCDB创建</p>
<ol>
<li>
<p>在目标CDB创建连接远程非CDB的dblink：</p>
<pre><code>SQL&gt; create   public database link nocdb1 connect to system identified by   &quot;111111&quot; using 'nocdb1';

Database link   created.
</code></pre>
</li>
<li>
<p>使用dblink远程创建</p>
<pre><code>SQL&gt; CREATE   PLUGGABLE DATABASE pdb6 FROM nocdb1@nocdb1                                                            
2      FILE_NAME_CONVERT = ('/u01/app/oracle/oradata/nocdb1/','/u01/app/oracle/oradata/orclcwd/pdb6/');

Pluggable   database created.
</code></pre>
</li>
<li>
<p>创建完成</p>
</li>
<li>
<p>执行PDB转换脚本</p>
<pre><code>SQL&gt; alter   session set container=pdb6;
SQL&gt;   @?/rdbms/admin/ noncdb_to_pdb.sql
</code></pre>
</li>
<li>
<p>Plug 过程的一些问题：</p>
<p>通过PDB_PLUG_IN_VIOLATIONS视图可以查询plug过程中的问题，例如以下，源PDB和当前CDB的字符集不同导致PDB open 后是限制模式，这个可以通过 ALTER DATABASE CHARACTER SET internal_use ZHS16GBK; 更改，如果在 实际应 用中就要事先注意 检查 字符集是否相同。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="二通过插拔方式创建create-pluggable-databaseusing-xml">二.通过插拔方式创建（CREATE PLUGGABLE DATABASE..USING ‘XML’..）</h1>
<pre><code>插拔的方式，是将一个PDB从CDB中拔出，之后插入到另外一个CDB的过程，一个拔掉的 PDB 由描述 PDB 的 XML 文件和其相关数据文件 组 成。
</code></pre>
<ol>
<li>
<p>从PDB插拔</p>
<ol>
<li>
<p>选择准备拔出的 PDB ，这里选择 PDB4.</p>
</li>
<li>
<p>关闭 PDB</p>
</li>
<li>
<p>生成PDB的描述XML文件</p>
<pre><code class="language-sql">ALTER PLUGGABLE DATABASE PDB4 UNPLUG INTO '/home/oracle/PDB4.xml';
</code></pre>
</li>
<li>
<p>将PDB4的文件传输到目标库相同路径下：</p>
</li>
<li>
<p>将生成的XML文件传输到目标库</p>
</li>
<li>
<p>执行DBMS_PDB.CHECK_PLUG_COMPATIBILITY 检查要插入PDB是否和目标CDB兼容。</p>
<pre><code class="language-sql">SET SERVEROUTPUT ON
DECLARE
    compatible CONSTANT VARCHAR2(3) :=
    CASE DBMS_PDB.CHECK_PLUG_COMPATIBILITY(
        pdb_descr_file =&gt;   '/home/oracle/PDB4.xml')
    WHEN TRUE THEN 'YES'
    ELSE 'NO'
END;
BEGIN
    DBMS_OUTPUT.PUT_LINE(compatible);
END;
/

SQL&gt;   SET SERVEROUTPUT ON
SQL&gt;   DECLARE
    2     compatible CONSTANT VARCHAR2(3) :=
    3      CASE DBMS_PDB.CHECK_PLUG_COMPATIBILITY(
    4          pdb_descr_file =&gt; '/home/oracle/PDB4.xml')
    5      WHEN TRUE THEN 'YES'
    6      ELSE 'NO'
    7    END;
    8    BEGIN
    9     DBMS_OUTPUT.PUT_LINE(compatible);
    10    END;
    11  /

NO  &lt;&lt;&lt;&lt; 检查不通过 ，原来出现字符集不同

SQL&gt;   ALTER SYSTEM ENABLE RESTRICTED SESSION;  
System altered.

SQL&gt; ALTER DATABASE CHARACTER SET internal_use ZHS16GBK;
Database altered.

SQL&gt;   SET SERVEROUTPUT ON
SQL&gt;   DECLARE
    2     compatible CONSTANT VARCHAR2(3) :=
    3      CASE DBMS_PDB.CHECK_PLUG_COMPATIBILITY(
    4          pdb_descr_file =&gt; '/home/oracle/PDB4.xml')
    5      WHEN TRUE THEN 'YES'
    6      ELSE 'NO'
    7    END;
    8    BEGIN
    9     DBMS_OUTPUT.PUT_LINE(compatible);
    10    END;
    11  /

YES &lt;&lt;&lt;&lt; 检查 通 过
PL/SQL procedure successfully completed.
</code></pre>
<p>对于插入一个PDB，必须满足以下条件：</p>
<pre><code>  目标CDB必须与源CDB具有相同的字节码（主要涉及平台问题） 。
  CDB必须安装相同的选项 。
  源CDB和目标CDB必须具有兼容的字符集和国家字符集。
</code></pre>
</li>
<li>
<p>使用XML元数据文件把PDB插入（克隆模式）</p>
<pre><code class="language-sql">create pluggable database MYPDB3 AS CLONE using '/home/oracle/PDB4.xml' NOCOPY TEMPFILE REUSE;
</code></pre>
<p>这里使用NOCOPY是因为将目标库数据文件路径设成了与源库相同。<br>
打开新的插入的PDB,但出现错误</p>
<pre><code class="language-sql">SQL&gt; !oerr ora 65054
65054, 00000, &quot;Cannot   open a pluggable database in the desired mode.&quot;
// *Cause:  An attempt was made to open a pluggable   database in a mode
//          incompatible with that of the CDB.
// *Action: Open the CDB   in a compatible mode first and retry the operation.
</code></pre>
<p>看起来是新的PDB和CDB OPEN时不兼容，这里我尝试重启整个CDB后竟然可以顺利打开新插入的PDB了。</p>
</li>
</ol>
</li>
<li>
<p>从 NON-CDB 插拔</p>
<p>从NON-CDB转换克隆的模式实际与从CDB相差不大，与从现有NOCDB创建的模式一样，这里也需要执行noncdb_to_pdb.sql脚本来转换数据字典等。</p>
<p>以下列举出执行的语句：</p>
<ol>
<li>
<p>关闭原NONCDB数据库,并开启到只读模式</p>
<pre><code class="language-sql">sqlplus / as sysdba
sql&gt; shutdown immediate
sql&gt; startup open read only
</code></pre>
</li>
<li>
<p>生成数据库的XML元数据文件。</p>
<pre><code class="language-sql">BEGIN
DBMS_PDB.DESCRIBE(pdb_descr_file   =&gt; '/home/oracle/12cNonPDB.xml');
END;
/
</code></pre>
</li>
<li>
<p>关闭数据库<br>
sql&gt; shutdown immediate</p>
</li>
<li>
<p>同样将原数据库文件传输到新数据库磁盘中。</p>
</li>
<li>
<p>检查兼容性</p>
<pre><code class="language-sql">SET SERVEROUTPUT ON;
DECLARE
compatible CONSTANT VARCHAR2(3) := CASE DBMS_PDB.CHECK_PLUG_COMPATIBILITY(pdb_descr_file =&gt; '/home/oracle/12cNonPDB.xml')
WHEN TRUE THEN 'YES'
ELSE 'NO'
END;
BEGIN
DBMS_OUTPUT.PUT_LINE(compatible);
END;
/
</code></pre>
</li>
<li>
<p>检查是否有错误</p>
<pre><code class="language-sql">col cause for a20
col name for a20
col message for a35 word_wrapped
select name,cause,type,message,status from PDB_PLUG_IN_VIOLATIONS where name='&lt;noncdb database name&gt;';
</code></pre>
</li>
<li>
<p>创建PDB</p>
<pre><code class="language-sql">CREATE PLUGGABLE DATABASE PDB8   USING ' /home/oracle/12cNonPDB.xml'
COPY
FILE_NAME_CONVERT = ('/u01/app/oracle/12c/oradata/12cNonPDB/','/u01/app/oracle/oradata/12c/PDB8/');
</code></pre>
</li>
<li>
<p>执行转换脚本</p>
<pre><code class="language-sql">sql&gt; ALTER SESSION SET CONTAINER= PDB8;
sql&gt; @$ORACLE_HOME/rdbms/admin/noncdb_to_pdb.sql
</code></pre>
</li>
<li>
<p>打开新的PDB</p>
<pre><code class="language-sql">ALTER PLUGGABLE DATABASE PDB8 OPEN;
</code></pre>
</li>
</ol>
</li>
</ol>
<h1 id="三通过rman备份恢复">三．通过RMAN备份恢复</h1>
<ol>
<li>
<p>整体数据库备份恢复</p>
<p>有时可能需要迁移的仅仅是其中某几个PDB，在整库数据量不大情况下，可以直接备份整库来异机恢复即可，这样和普通的的数据库模式是相同的。</p>
<ol>
<li>
<p>整库备份</p>
<pre><code class="language-sql">run{
allocate channel CH1 device type disk format  '/home/oracle/backup/full_db_%U';
backup database include current controlfile plus   archivelog  ;
release channel CH1 ;
}
BACKUP current controlfile  format '/home/oracle/backup/control_%d_%T_%u.ctl';
</code></pre>
</li>
<li>
<p>传输备份片到目标库</p>
<pre><code>[oracle@redhat1 ~]$ pwd
/home/oracle
[oracle@redhat1 ~]$  scp -r backup 172.16.155.67:/home/oracle/
</code></pre>
</li>
<li>
<p>恢复控制文件</p>
<pre><code class="language-sql">Startup nomout
restore controlfile from '/home/oracle/backup/control_ORCLCWD_20170819_1esc91u4.ctl';
alter database mount;
</code></pre>
</li>
<li>
<p>恢复全库</p>
<pre><code>run{
allocate channel CH1;
restore database ;
recover database;
release channel CH1 ;
}

alter database open resetlogs;
</code></pre>
</li>
</ol>
</li>
<li>
<p>只恢复CDB、pdb$seed和需要的PDB</p>
<ol>
<li>
<p>备份数据库</p>
<p>这里使用上一步骤的全库备份，这里有个问题，就是我只需要恢复其中某一个PDB，那么，是否可以直接备份root database ,种子pdb 和所要的pdb来单独恢复，这个在后面进行详细实验。</p>
</li>
<li>
<p>创建参数文件.</p>
<p>这个不做说明</p>
</li>
<li>
<p>恢复控制文件</p>
<pre><code class="language-sql">startup nomout
restore controlfile from '/home/oracle/backup/control_ORCLCWD_20170819_1esc91u4.ctl';
alter database mount;
</code></pre>
</li>
<li>
<p>恢复所需要的 CDB$ROOT,PDB$SEED和PDB4</p>
<pre><code>run{
ALLOCATE   CHANNEL c1 TYPE disk;
restore database root ;  -------------------------&gt;CDB$ROOT
restore database &quot;PDB$SEED&quot;;   --------&gt;PDB$SEED is required
restore database PDB4; --------------&gt;PDB   we want to restore
RELEASE CHANNEL c1;
}

如果源库和目标库的数据文件路径不同，这使用set new name方式来更改文件路径。
</code></pre>
</li>
<li>
<p>跳过不需要的PDB的表空间来做recover.</p>
<pre><code class="language-sql">在本示例中， 数据库中除了CDB$ROOT和PDB$SEED，还有PDB2和PDB4，选择恢复的是PDB4，因此PDB2在recover时必须进行排除。

run{
recover database skip forever tablespace PDB2:SYSTEM,PDB2:SYSAUX;
}
</code></pre>
</li>
<li>
<p>打开数据库</p>
<pre><code class="language-sql">打开后查看发现有pdb2，这个实际时不可用的，且没有实际数据，直接drop掉即可。
SQL&gt; show pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
        2  PDB$SEED                       MOUNTED
        3  PDB2                           MOUNTED
        5  PDB4                           MOUNTED

SQL&gt; alter pluggable database PDB2 open;
alter pluggable database PDB2 open
*
ERROR at line   1:
ORA-01147: SYSTEM tablespace file 8 is offline
SQL&gt; drop pluggable database pdb2 including datafiles;
Pluggable database dropped.

而在打开PDB4时报出了ORA-65086，这里可以试下插拔一次。

SQL&gt; alter pluggable database pdb4 open;
alter pluggable database pdb4 open
*
ERROR at line   1:
ORA-65086: cannot open/close the pluggable database

SQL&gt; alter pluggable database pdb4 unplug into '/tmp/pdb41.xml';

Pluggable database altered.

1* select   pdb_name,status from dba_pdbs

SQL&gt; /

PDB_NAME             STATUS
-------------------- ---------
PDB$SEED             NEW
PDB4                 UNPLUGGED

SQL&gt; drop pluggable database pdb4 keep datafiles;

Pluggable database dropped.

SQL&gt; select   pdb_name,status from dba_pdbs;

PDB_NAME             STATUS
-------------------- ---------
PDB$SEED             NEW

SQL&gt; create pluggable database PDB4 using '/tmp/pdb41.xml' nocopy tempfile reuse;
Pluggable database created.

SQL&gt; select pdb_name,status from dba_pdbs;

PDB_NAME             STATUS
-------------------- ---------
PDB4                 NEW
PDB$SEED             NEW

SQL&gt; alter pluggable database pdb4 open;

Pluggable database altered.

SQL&gt; show pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
         2 PDB$SEED                       MOUNTED
         3 PDB4                           READ WRITE NO



经过测试，可以只对需要的PDB进行备份后进行恢复即可,在迁移时并不需要整个库都备份，这样的话可以节省不少时间和空间。

run{
allocate   channel CH1 device type disk format    '/home/oracle/backup/full_db_%U';
backup database root include current   controlfile plus archivelog; 
backup    database &quot;PDB$SEED&quot;;
backup pluggable database PDB4 include   current controlfile plus archivelog;
release  channel CH1 ;
}
BACKUP current   controlfile  format '/home/oracle/backup/control_%d_%T_%u.ctl';

后面恢复的方法与以上相同。
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
</feed>